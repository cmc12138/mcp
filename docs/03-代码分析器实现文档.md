# 代码分析器实现文档

## 1. 概述

本文档详细描述了`FrontendCodeAnalyzer`类的实现细节，包括其核心功能、分析算法、实现方法和使用方式。

## 2. 类结构

### 2.1 类定义

```typescript
class FrontendCodeAnalyzer {
  private projectPath: string;        // 项目路径
  private projectInfo: ProjectInfo;   // 项目信息

  constructor(projectPath: string);
  async analyzeProject(): Promise<ProjectInfo>;
}
```

### 2.2 核心属性

- `projectPath`: 前端项目的根目录路径
- `projectInfo`: 分析结果的项目信息对象

## 3. 主要方法实现

### 3.1 构造函数

```typescript
constructor(projectPath: string) {
  this.projectPath = projectPath;
  this.projectInfo = {
    name: path.basename(projectPath),
    framework: 'unknown',
    files: [],
    dependencies: []
  };
}
```

**功能**: 初始化分析器，设置项目路径和默认项目信息。

### 3.2 项目分析主方法

```typescript
async analyzeProject(): Promise<ProjectInfo> {
  // 1. 检测框架类型
  this.detectFramework();
  
  // 2. 分析依赖
  await this.analyzeDependencies();
  
  // 3. 分析文件
  await this.analyzeFiles();
  
  return this.projectInfo;
}
```

**功能**: 执行完整的项目分析流程。

**分析步骤**:
1. 检测项目使用的前端框架
2. 分析项目依赖关系
3. 扫描和分析所有源代码文件

## 4. 框架检测实现

### 4.1 detectFramework 方法

```typescript
private detectFramework(): void {
  const packageJsonPath = path.join(this.projectPath, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    if (deps.react) this.projectInfo.framework = 'react';
    else if (deps.vue) this.projectInfo.framework = 'vue';
    else if (deps['@angular/core']) this.projectInfo.framework = 'angular';
    else this.projectInfo.framework = 'vanilla';
  }
}
```

**功能**: 通过分析package.json文件检测项目使用的前端框架。

**检测规则**:
- 存在`react`依赖 → React项目
- 存在`vue`依赖 → Vue项目
- 存在`@angular/core`依赖 → Angular项目
- 其他情况 → Vanilla JavaScript项目

## 5. 依赖分析实现

### 5.1 analyzeDependencies 方法

```typescript
private async analyzeDependencies(): Promise<void> {
  const packageJsonPath = path.join(this.projectPath, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    
    const deps = packageJson.dependencies || {};
    const devDeps = packageJson.devDependencies || {};
    const peerDeps = packageJson.peerDependencies || {};
    
    // 处理生产依赖
    Object.entries(deps).forEach(([name, version]) => {
      this.projectInfo.dependencies.push({
        name,
        version: version as string,
        type: 'dependency',
        usedIn: []
      });
    });
    
    // 处理开发依赖
    Object.entries(devDeps).forEach(([name, version]) => {
      this.projectInfo.dependencies.push({
        name,
        version: version as string,
        type: 'devDependency',
        usedIn: []
      });
    });
    
    // 处理同级依赖
    Object.entries(peerDeps).forEach(([name, version]) => {
      this.projectInfo.dependencies.push({
        name,
        version: version as string,
        type: 'peerDependency',
        usedIn: []
      });
    });
  }
}
```

**功能**: 分析项目的所有依赖包信息。

**处理内容**:
- 生产依赖 (dependencies)
- 开发依赖 (devDependencies)
- 同级依赖 (peerDependencies)

## 6. 文件分析实现

### 6.1 analyzeFiles 方法

```typescript
private async analyzeFiles(): Promise<void> {
  const files = this.getSourceFiles();
  
  for (const filePath of files) {
    const fileInfo = await this.analyzeFile(filePath);
    this.projectInfo.files.push(fileInfo);
  }
}
```

**功能**: 分析项目中的所有源代码文件。

### 6.2 getSourceFiles 方法

```typescript
private getSourceFiles(): string[] {
  const extensions = ['.js', '.jsx', '.ts', '.tsx', '.vue'];
  const files: string[] = [];
  
  const scanDirectory = (dir: string) => {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
        scanDirectory(fullPath);
      } else if (stat.isFile()) {
        const ext = path.extname(item);
        if (extensions.includes(ext)) {
          files.push(fullPath);
        }
      }
    }
  };
  
  scanDirectory(this.projectPath);
  return files;
}
```

**功能**: 递归扫描项目目录，获取所有源代码文件。

**支持的文件类型**:
- `.js` - JavaScript文件
- `.jsx` - React JSX文件
- `.ts` - TypeScript文件
- `.tsx` - React TypeScript文件
- `.vue` - Vue单文件组件

**排除的目录**:
- 以`.`开头的隐藏目录
- `node_modules`目录

### 6.3 analyzeFile 方法

```typescript
private async analyzeFile(filePath: string): Promise<FileInfo> {
  const content = fs.readFileSync(filePath, 'utf-8');
  const ast = babel.parseSync(content, {
    sourceType: 'module',
    plugins: ['jsx', 'typescript', 'decorators-legacy']
  });

  if (!ast) {
    throw new Error(`Failed to parse file: ${filePath}`);
  }

  const fileInfo: FileInfo = {
    path: filePath,
    type: this.determineFileType(filePath),
    variables: [],
    functions: [],
    components: []
  };

  // 分析变量
  this.analyzeVariables(ast, fileInfo);
  
  // 分析函数
  this.analyzeFunctions(ast, fileInfo);
  
  // 分析组件
  this.analyzeComponents(ast, fileInfo);

  return fileInfo;
}
```

**功能**: 分析单个源代码文件，提取变量、函数和组件信息。

**分析步骤**:
1. 读取文件内容
2. 使用Babel解析为AST
3. 确定文件类型
4. 分析变量
5. 分析函数
6. 分析组件

## 7. 变量分析实现

### 7.1 analyzeVariables 方法

```typescript
private analyzeVariables(ast: any, fileInfo: FileInfo): void {
  traverse(ast, {
    VariableDeclarator: (path: any) => {
      const variable = this.extractVariableInfo(path);
      if (variable) {
        fileInfo.variables.push(variable);
      }
    },
    FunctionDeclaration: (path: any) => {
      const variable = this.extractFunctionAsVariable(path);
      if (variable) {
        fileInfo.variables.push(variable);
      }
    },
    ClassDeclaration: (path: any) => {
      const variable = this.extractClassAsVariable(path);
      if (variable) {
        fileInfo.variables.push(variable);
      }
    }
  });
}
```

**功能**: 遍历AST，提取所有变量信息。

**处理的节点类型**:
- `VariableDeclarator`: 变量声明
- `FunctionDeclaration`: 函数声明
- `ClassDeclaration`: 类声明

### 7.2 extractVariableInfo 方法

```typescript
private extractVariableInfo(path: any): VariableInfo | null {
  const { node, parent } = path;
  
  if (!t.isIdentifier(node.id)) return null;
  
  const name = node.id.name;
  const declarationType = this.getDeclarationType(parent);
  const scope = this.determineScope(path);
  
  return {
    name,
    type: this.inferType(node.init),
    scope,
    declarationType,
    usage: [],
    dependencies: this.extractDependencies(node.init),
    isExported: this.isExported(path),
    isImported: false,
    line: node.loc?.start.line || 0,
    column: node.loc?.start.column || 0
  };
}
```

**功能**: 从变量声明节点提取变量信息。

### 7.3 类型推断实现

```typescript
private inferType(node: any): string {
  if (!node) return 'any';
  
  if (t.isStringLiteral(node)) return 'string';
  if (t.isNumericLiteral(node)) return 'number';
  if (t.isBooleanLiteral(node)) return 'boolean';
  if (t.isArrayExpression(node)) return 'array';
  if (t.isObjectExpression(node)) return 'object';
  if (t.isFunctionExpression(node) || t.isArrowFunctionExpression(node)) return 'function';
  if (t.isClassExpression(node)) return 'class';
  
  return 'any';
}
```

**功能**: 根据AST节点推断变量类型。

**支持的类型**:
- 字面量类型: string, number, boolean
- 复合类型: array, object, function, class
- 默认类型: any

### 7.4 作用域分析实现

```typescript
private determineScope(path: any): VariableInfo['scope'] {
  let current = path.parentPath;
  while (current) {
    if (t.isFunction(current.node) || t.isProgram(current.node)) {
      if (t.isProgram(current.node)) {
        return 'module';
      }
      return 'function';
    }
    current = current.parentPath;
  }
  return 'global';
}
```

**功能**: 分析变量的作用域。

**作用域类型**:
- `global`: 全局作用域
- `module`: 模块作用域
- `function`: 函数作用域
- `block`: 块作用域

## 8. 函数分析实现

### 8.1 analyzeFunctions 方法

```typescript
private analyzeFunctions(ast: any, fileInfo: FileInfo): void {
  traverse(ast, {
    FunctionDeclaration: (path: any) => {
      const func = this.extractFunctionInfo(path);
      if (func) {
        fileInfo.functions.push(func);
      }
    },
    ArrowFunctionExpression: (path: any) => {
      const func = this.extractArrowFunctionInfo(path);
      if (func) {
        fileInfo.functions.push(func);
      }
    }
  });
}
```

**功能**: 遍历AST，提取所有函数信息。

### 8.2 extractFunctionInfo 方法

```typescript
private extractFunctionInfo(path: any): FunctionInfo | null {
  const { node } = path;
  
  if (!t.isIdentifier(node.id)) return null;
  
  return {
    name: node.id.name,
    type: 'function',
    parameters: this.extractParameters(node.params),
    returnType: 'any',
    calls: this.extractFunctionCalls(node.body),
    calledBy: [],
    complexity: this.calculateComplexity(node.body),
    line: node.loc?.start.line || 0,
    column: node.loc?.start.column || 0
  };
}
```

**功能**: 从函数声明节点提取函数信息。

### 8.3 复杂度计算实现

```typescript
private calculateComplexity(body: any): number {
  let complexity = 1; // 基础复杂度
  
  traverse(body, {
    IfStatement: () => complexity++,
    ForStatement: () => complexity++,
    WhileStatement: () => complexity++,
    DoWhileStatement: () => complexity++,
    SwitchStatement: () => complexity++,
    CatchClause: () => complexity++,
    ConditionalExpression: () => complexity++,
    LogicalExpression: () => complexity++
  });
  
  return complexity;
}
```

**功能**: 计算函数的圈复杂度。

**复杂度计算规则**:
- 基础复杂度: 1
- 每个条件语句: +1
- 每个循环语句: +1
- 每个异常处理: +1
- 每个逻辑表达式: +1

## 9. 组件分析实现

### 9.1 analyzeComponents 方法

```typescript
private analyzeComponents(ast: any, fileInfo: FileInfo): void {
  traverse(ast, {
    FunctionDeclaration: (path: any) => {
      if (this.isReactComponent(path)) {
        const component = this.extractReactComponent(path);
        if (component) {
          fileInfo.components.push(component);
        }
      }
    },
    VariableDeclarator: (path: any) => {
      if (this.isReactComponent(path)) {
        const component = this.extractReactComponent(path);
        if (component) {
          fileInfo.components.push(component);
        }
      }
    }
  });
}
```

**功能**: 遍历AST，提取React组件信息。

### 9.2 isReactComponent 方法

```typescript
private isReactComponent(path: any): boolean {
  const { node } = path;
  
  // 检查是否返回JSX
  const hasJSX = this.hasJSXReturn(node);
  
  // 检查函数名是否以大写字母开头
  const hasComponentName = this.hasComponentName(node);
  
  return hasJSX && hasComponentName;
}
```

**功能**: 判断是否为React组件。

**判断条件**:
- 包含JSX返回语句
- 函数名以大写字母开头

### 9.3 extractReactComponent 方法

```typescript
private extractReactComponent(path: any): ComponentInfo | null {
  const { node } = path;
  
  let name = '';
  if (t.isFunctionDeclaration(node) && t.isIdentifier(node.id)) {
    name = node.id.name;
  } else if (t.isVariableDeclarator(node) && t.isIdentifier(node.id)) {
    name = node.id.name;
  }
  
  if (!name) return null;
  
  return {
    name,
    type: 'functional',
    props: this.extractProps(node),
    state: this.extractState(node),
    hooks: this.extractHooks(node),
    line: node.loc?.start.line || 0,
    column: node.loc?.start.column || 0
  };
}
```

**功能**: 从React组件节点提取组件信息。

### 9.4 Hook分析实现

```typescript
private extractHooks(node: any): HookInfo[] {
  const hooks: HookInfo[] = [];
  
  traverse(node, {
    CallExpression: (path: any) => {
      if (t.isIdentifier(path.node.callee) && 
          path.node.callee.name.startsWith('use')) {
        hooks.push({
          name: path.node.callee.name,
          type: 'hook',
          dependencies: this.extractHookDependencies(path.node.arguments),
          line: path.node.loc?.start.line || 0,
          column: path.node.loc?.start.column || 0
        });
      }
    }
  });
  
  return hooks;
}
```

**功能**: 提取React Hook使用信息。

## 10. 错误处理

### 10.1 解析错误处理

```typescript
try {
  const ast = babel.parseSync(content, {
    sourceType: 'module',
    plugins: ['jsx', 'typescript', 'decorators-legacy']
  });
  
  if (!ast) {
    throw new Error(`Failed to parse file: ${filePath}`);
  }
} catch (error) {
  console.error(`Parse error in ${filePath}:`, error);
  // 返回空的分析结果或跳过该文件
}
```

### 10.2 文件读取错误处理

```typescript
try {
  const content = fs.readFileSync(filePath, 'utf-8');
} catch (error) {
  console.error(`File read error: ${filePath}`, error);
  // 跳过该文件或返回错误信息
}
```

## 11. 性能优化

### 11.1 并行处理

```typescript
private async analyzeFiles(): Promise<void> {
  const files = this.getSourceFiles();
  
  // 并行处理文件分析
  const filePromises = files.map(filePath => this.analyzeFile(filePath));
  const fileInfos = await Promise.all(filePromises);
  
  this.projectInfo.files = fileInfos;
}
```

### 11.2 缓存机制

```typescript
private fileCache = new Map<string, FileInfo>();

private async analyzeFile(filePath: string): Promise<FileInfo> {
  // 检查缓存
  if (this.fileCache.has(filePath)) {
    return this.fileCache.get(filePath)!;
  }
  
  // 分析文件
  const fileInfo = await this.performFileAnalysis(filePath);
  
  // 缓存结果
  this.fileCache.set(filePath, fileInfo);
  
  return fileInfo;
}
```

## 12. 使用示例

### 12.1 基本使用

```typescript
const analyzer = new FrontendCodeAnalyzer('/path/to/project');
const projectInfo = await analyzer.analyzeProject();

console.log('项目名称:', projectInfo.name);
console.log('框架类型:', projectInfo.framework);
console.log('文件数量:', projectInfo.files.length);
```

### 12.2 错误处理

```typescript
try {
  const analyzer = new FrontendCodeAnalyzer('/path/to/project');
  const projectInfo = await analyzer.analyzeProject();
} catch (error) {
  console.error('分析失败:', error.message);
}
```

---

**文档版本**: v1.0  
**创建日期**: 2024年12月  
**最后更新**: 2024年12月  
**维护者**: AI助手
